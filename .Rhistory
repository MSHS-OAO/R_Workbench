dateRangeInput("date", strong("Date range"), start = min(covid_pts$CensusDate), end = max(covid_pts$CensusDate),
min = "2020-03-13", max = Sys.Date()-1),
# Select whether to overlay smooth trend line
checkboxInput(inputId = "smoother", label = strong("Overlay smooth trend line"), value = FALSE),
# Display only if the smoother is checked
conditionalPanel(condition = "input.smoother == true",
sliderInput(inputId = "f", label = "Smoother span:",
min = 0.01, max = 1, value = 0.67, step = 0.01,
animate = animationOptions(interval = 100)),
HTML("Higher values give more smoothness.")
)
),
# Output: Description, lineplot, and reference
mainPanel(
plotOutput(outputId = "lineplot", height = "300px"),
textOutput(outputId = "desc"),
)
)
)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$date)
validate(need(!is.na(input$date[1]) & !is.na(input$date[2]), "Error: Please provide both a start and an end date."))
validate(need(input$date[1] < input$date[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
date > as.POSIXct(input$date[1]) & date < as.POSIXct(input$date[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
# Display only if smoother is checked
if(input$smoother){
smooth_curve <- lowess(x = as.numeric(selected_trends()$CensusDate), y = selected_trends()$total, f = input$f)
lines(smooth_curve, col = "#E6553A", lwd = 3)
}
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
ggplot(covid_pts)+
geom_point(aes(x=CensusDate, y=total, shape=Unit, color=Unit))+
geom_line(aes(x=CensusDate, y=total, color=Unit))+
scale_shape_manual(values = 1:length(unique(covid_pts$Unit)),
guide = guide_legend(nrow = ceiling(length(unique(covid_pts$Unit))/6)))+
labs(x=NULL, y="Beds Occupied")+
theme_bw()+
theme(plot.title = element_text(size = 16, vjust = 2),
legend.position='top',
legend.justification='left',
legend.direction='horizontal',
legend.title = element_text(size = 10), legend.text = element_text(size = 10),
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
axis.text.y = element_text(size = 10),
panel.grid.major = element_line(color = "lightgrey"),
panel.grid.minor = element_line(color = "lightgrey"))+
scale_y_continuous(limits = c(0, max(covid_pts$total)*1.2), breaks= pretty_breaks())+
scale_x_date(breaks = "day", date_labels = "%m-%d", date_breaks = "2 days", date_minor_breaks = "1 day", expand = c(0, 0.6))
library(tidyverse)
View(covid_pts)
covid_pts$Unit[1]
ui <- fluidPage(theme = shinytheme("lumen"),
titlePanel("MSHS Census and Utilization Analysis"),
sidebarLayout(
sidebarPanel(
# Select type of trend to plot
selectInput(inputId = "Unit", label = strong("Trend index"),
choices = unique(covid_pts$Unit),
selected = "MSB 2 EAST"),
# Select date range to be plotted
dateRangeInput("date", strong("Date range"), start = min(covid_pts$CensusDate), end = max(covid_pts$CensusDate),
min = "2020-03-13", max = Sys.Date()-1),
# Display only if the smoother is checked
conditionalPanel(condition = "input.smoother == true",
sliderInput(inputId = "f", label = "Smoother span:",
min = 0.01, max = 1, value = 0.67, step = 0.01,
animate = animationOptions(interval = 100)),
HTML("Higher values give more smoothness."))
),
# Output: Description, lineplot, and reference
mainPanel(
plotOutput(outputId = "lineplot", height = "300px"),
textOutput(outputId = "desc"),
)
)
)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$date)
validate(need(!is.na(input$date[1]) & !is.na(input$date[2]), "Error: Please provide both a start and an end date."))
validate(need(input$date[1] < input$date[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
date > as.POSIXct(input$date[1]) & date < as.POSIXct(input$date[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
ui <- fluidPage(theme = shinytheme("lumen"),
titlePanel("MSHS Census and Utilization Analysis"),
sidebarLayout(
sidebarPanel(
# Select type of trend to plot
selectInput(inputId = "Unit", label = strong("Trend index"),
choices = unique(covid_pts$Unit),
selected = "MSB 2 EAST"),
# Select date range to be plotted
dateRangeInput("date", strong("Date range"), start = min(covid_pts$CensusDate), end = max(covid_pts$CensusDate),
min = "2020-03-13", max = Sys.Date()-1),
# Display only if the smoother is checked
conditionalPanel(condition = "input.smoother == true",
sliderInput(inputId = "f", label = "Smoother span:",
min = 0.01, max = 1, value = 0.67, step = 0.01,
animate = animationOptions(interval = 100)),
HTML("Higher values give more smoothness."))
),
# Output: Description, lineplot, and reference
mainPanel(
plotOutput(outputId = "lineplot", height = "300px"),
textOutput(outputId = "desc"),
)
)
)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$date)
validate(need(!is.na(input$date[1]) & !is.na(input$date[2]), "Error: Please provide both a start and an end date."))
validate(need(input$date[1] < input$date[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
date > as.POSIXct(input$date[1]) & date < as.POSIXct(input$date[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
ui <- fluidPage(theme = shinytheme("lumen"),
titlePanel("MSHS Census and Utilization Analysis"),
sidebarLayout(
sidebarPanel(
# Select type of trend to plot
selectInput(inputId = "Unit", label = strong("Trend index"),
choices = unique(covid_pts$Unit),
selected = "MSB 2 EAST"),
# Select date range to be plotted
dateRangeInput("CensusDate", strong("Date range"), start = min(covid_pts$CensusDate), end = max(covid_pts$CensusDate),
min = "2020-03-13", max = Sys.Date()-1),
# Display only if the smoother is checked
conditionalPanel(condition = "input.smoother == true",
sliderInput(inputId = "f", label = "Smoother span:",
min = 0.01, max = 1, value = 0.67, step = 0.01,
animate = animationOptions(interval = 100)),
HTML("Higher values give more smoothness."))
),
# Output: Description, lineplot, and reference
mainPanel(
plotOutput(outputId = "lineplot", height = "300px"),
textOutput(outputId = "desc"),
)
)
)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.POSIXct(input$CensusDate[1]) & CensusDate < as.POSIXct(input$CensusDate[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
class(covid_pts$total)
table(is.na(covid_pts$total))
ui <- fluidPage(theme = shinytheme("lumen"),
titlePanel("MSHS Census and Utilization Analysis"),
sidebarLayout(
sidebarPanel(
# Select type of trend to plot
selectInput(inputId = "Unit", label = strong("Trend index"),
choices = unique(covid_pts$Unit),
selected = "MSB 2 EAST"),
# Select date range to be plotted
dateRangeInput("CensusDate", strong("Date range"), start = min(covid_pts$CensusDate), end = max(covid_pts$CensusDate),
min = "2020-03-13", max = Sys.Date()-1),
# Display only if the smoother is checked
conditionalPanel(condition = "input.smoother == true",
sliderInput(inputId = "f", label = "Smoother span:",
min = 0.01, max = 1, value = 0.67, step = 0.01,
animate = animationOptions(interval = 100)),
HTML("Higher values give more smoothness."))
),
# Output: Description, lineplot, and reference
mainPanel(
plotOutput(outputId = "lineplot", height = "300px"),
textOutput(outputId = "desc"),
)
)
)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.POSIXct(input$CensusDate[1]) & CensusDate < as.POSIXct(input$CensusDate[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
#par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total, type = "l",
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.POSIXct(input$CensusDate[1]) & CensusDate < as.POSIXct(input$CensusDate[2]
))
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
color = "#434343"
#par(mar = c(4, 4, 1, 1))
plot(x = selected_trends()$CensusDate, y = selected_trends()$total,
xlab = "Date", ylab = "Beds Occupied", col = color, fg = color, col.lab = color, col.axis = color)
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.Date(input$CensusDate[1]) & CensusDate < as.Date(input$CensusDate[2] )
)
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
ggplot()+
geom_point(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
geom_line(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
scale_shape_manual(values = 1:length(unique(selected_trends()$Unit)),
guide = guide_legend(nrow = ceiling(length(unique(selected_trends()$Unit))/6)))+
labs(x=NULL, y="Beds Occupied")+
theme_bw()+
theme(plot.title = element_text(size = 16, vjust = 2),
# legend.position='top',
#legend.justification='left',
#legend.direction='horizontal',
#legend.title = element_text(size = 10), legend.text = element_text(size = 10),
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
axis.text.y = element_text(size = 10),
panel.grid.major = element_line(color = "lightgrey"),
panel.grid.minor = element_line(color = "lightgrey"))+
scale_y_continuous(limits = c(0, max(selected_trends()$total)*1.2), breaks= pretty_breaks())+
scale_x_date(breaks = "day", date_labels = "%m-%d", date_breaks = "2 days", date_minor_breaks = "1 day", expand = c(0, 0.6))
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.Date(input$CensusDate[1]) & CensusDate < as.Date(input$CensusDate[2] )
)
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
ggplot( covid_pts)+
geom_point(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
geom_line(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
scale_shape_manual(values = 1:length(unique(selected_trends()$Unit)),
guide = guide_legend(nrow = ceiling(length(unique(selected_trends()$Unit))/6)))+
labs(x=NULL, y="Beds Occupied")+
theme_bw()+
theme(plot.title = element_text(size = 16, vjust = 2),
# legend.position='top',
#legend.justification='left',
#legend.direction='horizontal',
#legend.title = element_text(size = 10), legend.text = element_text(size = 10),
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
axis.text.y = element_text(size = 10),
panel.grid.major = element_line(color = "lightgrey"),
panel.grid.minor = element_line(color = "lightgrey"))+
scale_y_continuous(limits = c(0, max(selected_trends()$total)*1.2), breaks= pretty_breaks())+
scale_x_date(breaks = "day", date_labels = "%m-%d", date_breaks = "2 days", date_minor_breaks = "1 day", expand = c(0, 0.6))
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.Date(input$CensusDate[1]) & CensusDate < as.Date(input$CensusDate[2] )
)
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
ggplot( aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
geom_line(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
scale_shape_manual(values = 1:length(unique(selected_trends()$Unit)),
guide = guide_legend(nrow = ceiling(length(unique(selected_trends()$Unit))/6)))+
labs(x=NULL, y="Beds Occupied")+
theme_bw()+
theme(plot.title = element_text(size = 16, vjust = 2),
# legend.position='top',
#legend.justification='left',
#legend.direction='horizontal',
#legend.title = element_text(size = 10), legend.text = element_text(size = 10),
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
axis.text.y = element_text(size = 10),
panel.grid.major = element_line(color = "lightgrey"),
panel.grid.minor = element_line(color = "lightgrey"))+
scale_y_continuous(limits = c(0, max(selected_trends()$total)*1.2), breaks= pretty_breaks())+
scale_x_date(breaks = "day", date_labels = "%m-%d", date_breaks = "2 days", date_minor_breaks = "1 day", expand = c(0, 0.6))
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
# Define server function
server <- function(input, output) {
# Subset data
selected_trends <- reactive({
req(input$CensusDate)
validate(need(!is.na(input$CensusDate[1]) & !is.na(input$CensusDate[2]), "Error: Please provide both a start and an end date."))
validate(need(input$CensusDate[1] < input$CensusDate[2], "Error: Start date should be earlier than end date."))
covid_pts %>%
filter(
Unit == input$Unit,
CensusDate > as.Date(input$CensusDate[1]) & CensusDate < as.Date(input$CensusDate[2] )
)
})
# Create scatterplot object the plotOutput function is expecting
output$lineplot <- renderPlot({
ggplot(x=selected_trends()$CensusDate, y=selected_trends()$total)+
geom_line(aes(x=selected_trends()$CensusDate, y=selected_trends()$total))+
scale_shape_manual(values = 1:length(unique(selected_trends()$Unit)),
guide = guide_legend(nrow = ceiling(length(unique(selected_trends()$Unit))/6)))+
labs(x=NULL, y="Beds Occupied")+
theme_bw()+
theme(plot.title = element_text(size = 16, vjust = 2),
# legend.position='top',
#legend.justification='left',
#legend.direction='horizontal',
#legend.title = element_text(size = 10), legend.text = element_text(size = 10),
axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
axis.text.y = element_text(size = 10),
panel.grid.major = element_line(color = "lightgrey"),
panel.grid.minor = element_line(color = "lightgrey"))+
scale_y_continuous(limits = c(0, max(selected_trends()$total)*1.2), breaks= pretty_breaks())+
scale_x_date(breaks = "day", date_labels = "%m-%d", date_breaks = "2 days", date_minor_breaks = "1 day", expand = c(0, 0.6))
})
}
# Create Shiny object
shinyApp(ui = ui, server = server)
max(covid_pts$CensusDate)
rm(list=ls())
# Import Libraries
library(tidyverse)
library(dplyr)
library(readxl)
library(writexl)
library(reshape2)
library(svDialogs)
library(formattable)
library(scales)
library(ggpubr)
library(knitr)
library(kableExtra)
library(rmarkdown)
# Set working directory
Census_path <- "J:/deans/Presidents/HSPI-PM/Operations Analytics and Optimization/Projects/System Operations/Covid IP Staffing Model/Data/Epic Census Data"
setwd(Census_path)
dates_pattern <-  seq(Sys.Date()-5, Sys.Date(), by='day')
#Import the latest REPO file
repo <- file.info(list.files(path = paste0(Census_path,"/REPO"), full.names = T , pattern =paste0("Census and Covid Repo 2020-03-12 to ", dates_pattern, collapse = "|"  )))
# Set working directory
Census_path <- "J:/deans/Presidents/HSPI-PM/Operations Analytics and Optimization/Projects/System Operations/Covid IP Staffing Model/Data/Epic Census Data"
setwd(Census_path)
getwd()
rm(list=ls())
# Set working directory
Census_path <- "J:/deans/Presidents/HSPI-PM/Operations Analytics and Optimization/Projects/System Operations/Covid IP Staffing Model/Data/Epic Census Data"
setwd(Census_path)
Census_path
setwd( "J:/deans/Presidents/HSPI-PM/Operations Analytics and Optimization/Projects/System Operations/Covid IP Staffing Model/Data/Epic Census Data")
setwd(Census_path)
rm(list=ls())
# Import Libraries
library(tidyverse)
library(dplyr)
library(readxl)
library(writexl)
library(reshape2)
library(svDialogs)
library(formattable)
library(scales)
library(ggpubr)
library(knitr)
library(kableExtra)
library(rmarkdown)
# Set working directory
Census_path <- "J:/deans/Presidents/HSPI-PM/Operations Analytics and Optimization/Projects/System Operations/Covid IP Staffing Model/Data/Epic Census Data"
setwd(Census_path)
source("global.R")
source("global.R")
install.packages("renv")
library(renv)
library(tidyverse)
#set working directory
setwd("C:/Users/aghaer01/Downloads/Renv Library")
# Import libraries
library(readxl)
library(tidyverse)
library(renv)
.libPaths()
# 2. Initialize renv: this set up the project with a private library recorded into a lockfile, called renv.lock.
# The renv.lock lockfile records the state of the project's private library, and can be used to restore the state of that library as required.
renv::init(renv::init(force = TRUE))
.libPaths()
# check packages in lockfile
renv::dependencies()
# 2. Initialize renv: this set up the project with a private library recorded into a lockfile, called renv.lock.
# The renv.lock lockfile records the state of the project's private library, and can be used to restore the state of that library as required.
renv::init(renv::init(force = TRUE))
# check packages in lockfile
renv::dependencies()
# save the state of libraries to the lockfile
renv::snapshot() # running the code, it asks if we would like to activate the project. Say Y, then it updates libraries.
renv::deactivate()
.libPaths()
# 2. Initialize renv: this set up the project with a private library recorded into a lockfile, called renv.lock.
# The renv.lock lockfile records the state of the project's private library, and can be used to restore the state of that library as required.
renv::init(renv::init(force = TRUE))
